package com.liyafeng.practice;

import android.content.Context;

/**
 * Created by liyafeng on 16/11/2017.
 */

public class Tools {

    /**
     * 编译打包的过程
     * http://blog.csdn.net/luoshengyang/article/details/8744683
     * http://mouxuejie.com/blog/2016-08-04/build-and-package-flow-introduction/
     */
    void a1(Context context) {
        context.getResources().getDrawable(R.drawable.build_simplified);
        /*
        *
        * */
    }

    /**
     * android studio 目录下build/下的文件夹都是什么作用？
     */
    public void a1_1() {
        /*
        * The "generated" folder contains java code generated by Android Studio for the module. The primary file here is "R.java" which assigns symbolic names to each of the items in the "res" directory so they can be referenced in java source code.

        *The "intermediates" folder contains individual files that are created during the build process and which are eventually combined to produce the "apk" file.
        *
        *The output folder is missing because the module ".iml" file explicitly excludes it with the following statement:
        *
        *<excludeFolder url="file://$MODULE_DIR$/build/outputs" />
        *
        *Remove that line and the "output" directory will appear under build.
        */
    }

    /**
     * android-apt的使用?
     * https://joyrun.github.io/2016/07/19/AptHelloWorld/
     * https://www.jianshu.com/p/2494825183c5
     * https://juejin.im/entry/584a29a5128fe1006c7923a5
     * */
    public void a1_2(){
        /*
        * 最早我们用android-apt 这个工具，但是现在已经维护了
        * 因为Gradle推出了官方的处理工具 annotationProcessor
        *
        * Annotation Processing Tool 注解处理工具，用注解来生成代码
        */
        //这是以前的android-apt工具使用
//        buildscript {
//            repositories {
//                jcenter()
//            }
//            dependencies {
//                classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
//            }
//        }
//        apply plugin: 'com.neenbedankt.android-apt'
//        dependencies {
//            compile 'org.greenrobot:eventbus:3.0.0'
//            apt'org.greenrobot:eventbus-annotation-processor:3.0.1'//apt
//        }

        //Gradle自带的  annotationProcessor
//        dependencies {
//            compile 'org.greenrobot:eventbus:3.0.0'
//            annotationProcessor  'org.greenrobot:eventbus-annotation-processor:3.0.1'
//        }
    }


    /**
     * 谈谈你对安卓签名的理解?
     * https://blog.csdn.net/jiangwei0910410003/article/details/50402000（signapk.jar源码分析）
     * https://juejin.im/entry/575ed0bb1532bc00609c3aa9
     * https://maoao530.github.io/2017/01/31/apk-sign/
     * */
    public void a2(){
        /*
        * 整个过程用到了SHA-1 的hash算法，和RSA非对称加密
        * 首先签名过程就是在apk(压缩包)中生成一个META-INF文件夹，里面有三个文件
        * MANIFEST.MF  CERT.SF  CERT.RSA 文件，我们就是靠这三个文件来验证apk是没有
        * 被修改过的。
        *   而产生这三个文件的程序就是用 apksigner.jar用xxx.keystore来生成的，
        * xxx.keystore中存储了公钥和私钥 ，而生成xxx.keystore 需要用keytool.jar这个工具
        * keytool -genkeypair -v -keyalg DSA -keysize 1024 -sigalg SHA1withDSA -validity 20000 -keystore D:\xxx.keystore -alias 别名 -keypass 使用密码 -storepass 打包密码？
        * apksigner 签名时用的是pk8和x509.pem文件，xxx.keystore文件可以转化为他们
        * apksigner.jar 源码分析 源码位置：com/android/signapk/sign.java
        * 1，
        * 2
        * 3
        */
    }
}
