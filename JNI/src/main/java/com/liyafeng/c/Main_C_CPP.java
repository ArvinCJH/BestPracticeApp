package com.liyafeng.c;

public class Main_C_CPP {


    /**
     * C语言的原型ALGOL 60语言。（也称为A语言）  1963年，
     * 剑桥大学将ALGOL 60语言发展成为CPL(Combined Programming Language)语言。
     * 1967年，剑桥大学的Matin Richards 对CPL语言进行了简化，于是产生了BCPL语言。
     * 1970年，美国贝尔实验室的Ken Thompson将BCPL进行了修改，并为它起了一个有趣的名字“B语言”。
     * 意思是将CPL语言煮干，提炼出它的精华。并且他用B语言写了第一个UNIX操作系统。
     * 而在1973年，B语言也给人“煮”了一下，
     * 美国贝尔实验室的D.M.RITCHIE在B语言的基础上最终设计出了一种新的语言，
     * 他取了BCPL的第二个字母作为这种语言的名字，这就是C语言。
     * 所以，最早的C语言编译器使用B语言写的。
     *
     * 作者：12345
     * 链接：https://www.zhihu.com/question/20369232/answer/14920514
     * 来源：知乎
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     *
     * @param args
     */
    public static void main(String[] args) {

    }

    /**
     * mac 自带编译软件，gcc/g++
     * gcc --version
     * g++ --help
     * <p>
     * =========gcc/g++区别========
     * 后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序
     * 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，
     * 但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了
     */
    public void fun1() {
    }


    /**
     * C++
     * =========取地址运算符 间接寻址运算符============
     * int n=5;
     * &n是返回变量n的地址 （取地址运算符）
     * <p>
     * int *p;
     * <p>
     * p=&n;
     * <p>
     * *p 就是5，p的值是个地址，*是来访问这个地址的值
     * <p>
     * ===========指针=======
     * int    *ip;    一个整型的指针
     * double *dp;    一个 double 型的指针
     * float  *fp;    一个浮点型的指针
     * char   *ch;    一个字符型的指针
     *
     * 这是定义指针，代表只用分配地址大小的空间就可以了
     * 有了地址后，后面多少位是数据？int是32位，所以要声明指针类型
     *
     * 地址开始存储的值 = *(地址)
     *
     * C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量
     *
     * int* p; 实际上定义p这个变量是个指向 int的指针
     * 为啥非得加* ，是因为这样内存分配的时候 就分配指针 大小的空间
     * 重点是定义（指针）变量p
     * 而 *p *是寻址运算符，访问的是p地址开始的 整型
     * ======================运算符=======================
     * ::：域运算符
     * #： 预处理符号
     * .*, ->*：成员指针访问运算符
     * .：成员访问运算符
     *
     * ======================#include <iostream>============
     * 包含类 iostream
     *
     * ================抽象类================
     * 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。
     * 抽象类不能被用于实例化对象，它只能作为接口使用
     * C++ 接口是使用抽象类来实现的
     *
     * ============流提取运算符（ >> ）==============
     *
     * ===================new======================
     * new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。
     *
     * -===============命名空间=======================
     * 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称
     * std::cout<<"123"<<std::endl
     *
     * using 指令也可以用来指定命名空间中的特定项目
     * using std::cout;
     *
     * =================C++ 预处理器=============================
     * 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。
     * 井号（#）开头
     * 预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。
     *
     *
     */
    public void fun2() {
    }

    /**
     * 关键字 virtual
     * 如果继承的父类的方法不加virtual
     * 静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定
     *
     * 加上virtual
     * 调用的是子类，实际类型的方法
     *
     * 在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
     *
     *  // pure virtual function
     *       virtual int area() = 0;
     */
    public void fun3(){

    }
}
